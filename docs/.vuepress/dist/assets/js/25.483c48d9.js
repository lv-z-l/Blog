(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{578:function(e,a,s){"use strict";s.r(a);var o=s(12),r=Object(o.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("p",[e._v("Node 应用由模块组成，采用 CommonJS 模块规范。")]),e._v(" "),s("p",[e._v("每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// example.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\n")])])]),s("p",[e._v("上面代码中，变量"),s("code",[e._v("x")]),e._v("和函数"),s("code",[e._v("addX")]),e._v("，是当前文件"),s("code",[e._v("example.js")]),e._v("私有的，其他文件不可见。")]),e._v(" "),s("p",[e._v("如果想在多个文件分享变量，必须定义为"),s("code",[e._v("global")]),e._v("对象的属性。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("global.warning = true;\n")])])]),s("p",[e._v("上面代码的"),s("code",[e._v("warning")]),e._v("变量，可以被所有文件读取。当然，这样写法是不推荐的。")]),e._v(" "),s("p",[e._v("CommonJS规范规定，每个模块内部，"),s("code",[e._v("module")]),e._v("变量代表当前模块。这个变量是一个对象，它的"),s("code",[e._v("exports")]),e._v("属性（即"),s("code",[e._v("module.exports")]),e._v("）是对外的接口。加载某个模块，其实是加载该模块的"),s("code",[e._v("module.exports")]),e._v("属性。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n")])])]),s("p",[e._v("上面代码通过"),s("code",[e._v("module.exports")]),e._v("输出变量"),s("code",[e._v("x")]),e._v("和函数"),s("code",[e._v("addX")]),e._v("。")]),e._v(" "),s("p",[s("code",[e._v("require")]),e._v("方法用于加载模块。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var example = require('./example.js');\n\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n")])])]),s("p",[s("code",[e._v("require")]),e._v("方法的详细解释参见《Require命令》一节。")]),e._v(" "),s("p",[e._v("CommonJS模块的特点如下。")]),e._v(" "),s("ul",[s("li",[e._v("所有代码都运行在模块作用域，不会污染全局作用域。")]),e._v(" "),s("li",[e._v("模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。")]),e._v(" "),s("li",[e._v("模块加载的顺序，按照其在代码中出现的顺序。")])]),e._v(" "),s("h2",{attrs:{id:"module对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#module对象"}},[e._v("#")]),e._v(" module对象")]),e._v(" "),s("p",[e._v("Node内部提供一个"),s("code",[e._v("Module")]),e._v("构建函数。所有模块都是"),s("code",[e._v("Module")]),e._v("的实例。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  // ...\n")])])]),s("p",[e._v("每个模块内部，都有一个"),s("code",[e._v("module")]),e._v("对象，代表当前模块。它有以下属性。")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("module.id")]),e._v(" 模块的识别符，通常是带有绝对路径的模块文件名。")]),e._v(" "),s("li",[s("code",[e._v("module.filename")]),e._v(" 模块的文件名，带有绝对路径。")]),e._v(" "),s("li",[s("code",[e._v("module.loaded")]),e._v(" 返回一个布尔值，表示模块是否已经完成加载。")]),e._v(" "),s("li",[s("code",[e._v("module.parent")]),e._v(" 返回一个对象，表示调用该模块的模块。")]),e._v(" "),s("li",[s("code",[e._v("module.children")]),e._v(" 返回一个数组，表示该模块要用到的其他模块。")]),e._v(" "),s("li",[s("code",[e._v("module.exports")]),e._v(" 表示模块对外输出的值。")])]),e._v(" "),s("p",[e._v("下面是一个示例文件，最后一行输出module变量。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// example.js\nvar jquery = require('jquery');\nexports.$ = jquery;\nconsole.log(module);\n")])])]),s("p",[e._v("执行这个文件，命令行会输出如下信息。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("{ id: '.',\n  exports: { '$': [Function] },\n  parent: null,\n  filename: '/path/to/example.js',\n  loaded: false,\n  children:\n   [ { id: '/path/to/node_modules/jquery/dist/jquery.js',\n       exports: [Function],\n       parent: [Circular],\n       filename: '/path/to/node_modules/jquery/dist/jquery.js',\n       loaded: true,\n       children: [],\n       paths: [Object] } ],\n  paths:\n   [ '/home/user/deleted/node_modules',\n     '/home/user/node_modules',\n     '/home/node_modules',\n     '/node_modules' ]\n}\n")])])]),s("p",[e._v("如果在命令行下调用某个模块，比如"),s("code",[e._v("node something.js")]),e._v("，那么"),s("code",[e._v("module.parent")]),e._v("就是"),s("code",[e._v("null")]),e._v("。如果是在脚本之中调用，比如"),s("code",[e._v("require('./something.js')")]),e._v("，那么"),s("code",[e._v("module.parent")]),e._v("就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (!module.parent) {\n    // ran with `node something.js`\n    app.listen(8088, function() {\n        console.log('app listening on port 8088');\n    })\n} else {\n    // used with `require('/.something.js')`\n    module.exports = app;\n}\n")])])]),s("h3",{attrs:{id:"module-exports属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#module-exports属性"}},[e._v("#")]),e._v(" module.exports属性")]),e._v(" "),s("p",[s("code",[e._v("module.exports")]),e._v("属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取"),s("code",[e._v("module.exports")]),e._v("变量。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var EventEmitter = require('events').EventEmitter;\nmodule.exports = new EventEmitter();\n\nsetTimeout(function() {\n  module.exports.emit('ready');\n}, 1000);\n")])])]),s("p",[e._v("上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var a = require('./a');\na.on('ready', function() {\n  console.log('module a is ready');\n});\n")])])]),s("h3",{attrs:{id:"exports变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exports变量"}},[e._v("#")]),e._v(" exports变量")]),e._v(" "),s("p",[e._v("为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var exports = module.exports;\n")])])]),s("p",[e._v("造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("exports.area = function (r) {\n  return Math.PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * Math.PI * r;\n};\n")])])]),s("p",[e._v("注意，不能直接将exports变量指向一个值，因为这样等于切断了"),s("code",[e._v("exports")]),e._v("与"),s("code",[e._v("module.exports")]),e._v("的联系。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("exports = function(x) {console.log(x)};\n")])])]),s("p",[e._v("上面这样的写法是无效的，因为"),s("code",[e._v("exports")]),e._v("不再指向"),s("code",[e._v("module.exports")]),e._v("了。")]),e._v(" "),s("p",[e._v("下面的写法也是无效的。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("exports.hello = function() {\n  return 'hello';\n};\n\nmodule.exports = 'Hello world';\n")])])]),s("p",[e._v("上面代码中，"),s("code",[e._v("hello")]),e._v("函数是无法对外输出的，因为"),s("code",[e._v("module.exports")]),e._v("被重新赋值了。")]),e._v(" "),s("p",[e._v("这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用"),s("code",[e._v("exports")]),e._v("输出，只能使用"),s("code",[e._v("module.exports")]),e._v("输出。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("module.exports = function (x){ console.log(x);};\n")])])]),s("p",[e._v("如果你觉得，"),s("code",[e._v("exports")]),e._v("与"),s("code",[e._v("module.exports")]),e._v("之间的区别很难分清，一个简单的处理方法，就是放弃使用"),s("code",[e._v("exports")]),e._v("，只使用"),s("code",[e._v("module.exports")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"amd规范与commonjs规范的兼容性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd规范与commonjs规范的兼容性"}},[e._v("#")]),e._v(" AMD规范与CommonJS规范的兼容性")]),e._v(" "),s("p",[e._v("CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。")]),e._v(" "),s("p",[e._v("AMD规范使用define方法定义模块，下面就是一个例子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("define(['package/lib'], function(lib){\n  function foo(){\n    lib.log('hello world!');\n  }\n\n  return {\n    foo: foo\n  };\n});\n")])])]),s("p",[e._v("AMD规范允许输出的模块兼容CommonJS规范，这时"),s("code",[e._v("define")]),e._v("方法需要写成下面这样：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('define(function (require, exports, module){\n  var someModule = require("someModule");\n  var anotherModule = require("anotherModule");\n\n  someModule.doTehAwesome();\n  anotherModule.doMoarAwesome();\n\n  exports.asplode = function (){\n    someModule.doTehAwesome();\n    anotherModule.doMoarAwesome();\n  };\n});\n')])])]),s("h2",{attrs:{id:"require命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require命令"}},[e._v("#")]),e._v(" require命令")]),e._v(" "),s("h3",{attrs:{id:"基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[e._v("#")]),e._v(" 基本用法")]),e._v(" "),s("p",[e._v("Node使用CommonJS模块规范，内置的"),s("code",[e._v("require")]),e._v("命令用于加载模块文件。")]),e._v(" "),s("p",[s("code",[e._v("require")]),e._v("命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// example.js\nvar invisible = function () {\n  console.log("invisible");\n}\n\nexports.message = "hi";\n\nexports.say = function () {\n  console.log(message);\n}\n')])])]),s("p",[e._v("运行下面的命令，可以输出exports对象。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var example = require('./example.js');\nexample\n// {\n//   message: \"hi\",\n//   say: [Function]\n// }\n")])])]),s("p",[e._v("如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在"),s("code",[e._v("module.exports")]),e._v("变量上面。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("module.exports = function () {\n  console.log(\"hello world\")\n}\n\nrequire('./example2.js')()\n")])])]),s("p",[e._v("上面代码中，require命令调用自身，等于是执行"),s("code",[e._v("module.exports")]),e._v("，因此会输出 hello world。")]),e._v(" "),s("h3",{attrs:{id:"加载规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加载规则"}},[e._v("#")]),e._v(" 加载规则")]),e._v(" "),s("p",[s("code",[e._v("require")]),e._v("命令用于加载文件，后缀名默认为"),s("code",[e._v(".js")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var foo = require('foo');\n//  等同于\nvar foo = require('foo.js');\n")])])]),s("p",[e._v("根据参数的不同格式，"),s("code",[e._v("require")]),e._v("命令去不同路径寻找模块文件。")]),e._v(" "),s("p",[e._v("（1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，"),s("code",[e._v("require('/home/marco/foo.js')")]),e._v("将加载"),s("code",[e._v("/home/marco/foo.js")]),e._v("。")]),e._v(" "),s("p",[e._v("（2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，"),s("code",[e._v("require('./circle')")]),e._v("将加载当前脚本同一目录的"),s("code",[e._v("circle.js")]),e._v("。")]),e._v(" "),s("p",[e._v("（3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。")]),e._v(" "),s("p",[e._v("举例来说，脚本"),s("code",[e._v("/home/user/projects/foo.js")]),e._v("执行了"),s("code",[e._v("require('bar.js')")]),e._v("命令，Node会依次搜索以下文件。")]),e._v(" "),s("ul",[s("li",[e._v("/usr/local/lib/node/bar.js")]),e._v(" "),s("li",[e._v("/home/user/projects/node_modules/bar.js")]),e._v(" "),s("li",[e._v("/home/user/node_modules/bar.js")]),e._v(" "),s("li",[e._v("/home/node_modules/bar.js")]),e._v(" "),s("li",[e._v("/node_modules/bar.js")])]),e._v(" "),s("p",[e._v("这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。")]),e._v(" "),s("p",[e._v("（4）如果参数字符串不以“./“或”/“开头，而且是一个路径，比如"),s("code",[e._v("require('example-module/path/to/file')")]),e._v("，则将先找到"),s("code",[e._v("example-module")]),e._v("的位置，然后再以它为参数，找到后续路径。")]),e._v(" "),s("p",[e._v("（5）如果指定的模块文件没有发现，Node会尝试为文件名添加"),s("code",[e._v(".js")]),e._v("、"),s("code",[e._v(".json")]),e._v("、"),s("code",[e._v(".node")]),e._v("后，再去搜索。"),s("code",[e._v(".js")]),e._v("件会以文本格式的JavaScript脚本文件解析，"),s("code",[e._v(".json")]),e._v("文件会以JSON格式的文本文件解析，"),s("code",[e._v(".node")]),e._v("文件会以编译后的二进制文件解析。")]),e._v(" "),s("p",[e._v("（6）如果想得到"),s("code",[e._v("require")]),e._v("命令加载的确切文件名，使用"),s("code",[e._v("require.resolve()")]),e._v("方法。")]),e._v(" "),s("h3",{attrs:{id:"目录的加载规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录的加载规则"}},[e._v("#")]),e._v(" 目录的加载规则")]),e._v(" "),s("p",[e._v("通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让"),s("code",[e._v("require")]),e._v("方法可以通过这个入口文件，加载整个目录。")]),e._v(" "),s("p",[e._v("在目录中放置一个"),s("code",[e._v("package.json")]),e._v("文件，并且将入口文件写入"),s("code",[e._v("main")]),e._v("字段。下面是一个例子。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// package.json\n{ "name" : "some-library",\n  "main" : "./lib/some-library.js" }\n')])])]),s("p",[s("code",[e._v("require")]),e._v("发现参数字符串指向一个目录以后，会自动查看该目录的"),s("code",[e._v("package.json")]),e._v("文件，然后加载"),s("code",[e._v("main")]),e._v("字段指定的入口文件。如果"),s("code",[e._v("package.json")]),e._v("文件没有"),s("code",[e._v("main")]),e._v("字段，或者根本就没有"),s("code",[e._v("package.json")]),e._v("文件，则会加载该目录下的"),s("code",[e._v("index.js")]),e._v("文件或"),s("code",[e._v("index.node")]),e._v("文件。")]),e._v(" "),s("h3",{attrs:{id:"模块的缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块的缓存"}},[e._v("#")]),e._v(" 模块的缓存")]),e._v(" "),s("p",[e._v("第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的"),s("code",[e._v("module.exports")]),e._v("属性。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("require('./example.js');\nrequire('./example.js').message = \"hello\";\nrequire('./example.js').message\n// \"hello\"\n")])])]),s("p",[e._v("上面代码中，连续三次使用"),s("code",[e._v("require")]),e._v("命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个"),s("code",[e._v("message")]),e._v("属性。但是第三次加载的时候，这个message属性依然存在，这就证明"),s("code",[e._v("require")]),e._v("命令并没有重新加载模块文件，而是输出了缓存。")]),e._v(" "),s("p",[e._v("如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次"),s("code",[e._v("require")]),e._v("这个模块的时候，重新执行一下输出的函数。")]),e._v(" "),s("p",[e._v("所有缓存的模块保存在"),s("code",[e._v("require.cache")]),e._v("之中，如果想删除模块的缓存，可以像下面这样写。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 删除指定模块的缓存\ndelete require.cache[moduleName];\n\n// 删除所有模块的缓存\nObject.keys(require.cache).forEach(function(key) {\n  delete require.cache[key];\n})\n")])])]),s("p",[e._v("注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，"),s("code",[e._v("require")]),e._v("命令还是会重新加载该模块。")]),e._v(" "),s("h3",{attrs:{id:"环境变量node-path"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环境变量node-path"}},[e._v("#")]),e._v(" 环境变量NODE_PATH")]),e._v(" "),s("p",[e._v("Node执行一个脚本时，会先查看环境变量"),s("code",[e._v("NODE_PATH")]),e._v("。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。")]),e._v(" "),s("p",[e._v("可以将NODE_PATH添加到"),s("code",[e._v(".bashrc")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('export NODE_PATH="/usr/local/lib/node"\n')])])]),s("p",[e._v("所以，如果遇到复杂的相对路径，比如下面这样。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var myModule = require('../../../../lib/myModule');\n")])])]),s("p",[e._v("有两种解决方法，一是将该文件加入"),s("code",[e._v("node_modules")]),e._v("目录，二是修改"),s("code",[e._v("NODE_PATH")]),e._v("环境变量，"),s("code",[e._v("package.json")]),e._v("文件可以采用下面的写法。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n  "name": "node_path",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.js",\n  "scripts": {\n    "start": "NODE_PATH=lib node index.js"\n  },\n  "author": "",\n  "license": "ISC"\n}\n')])])]),s("p",[s("code",[e._v("NODE_PATH")]),e._v("是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用"),s("code",[e._v("node_modules")]),e._v("目录机制。")]),e._v(" "),s("h3",{attrs:{id:"模块的循环加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块的循环加载"}},[e._v("#")]),e._v(" 模块的循环加载")]),e._v(" "),s("p",[e._v("如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// a.js\nexports.x = 'a1';\nconsole.log('a.js ', require('./b.js').x);\nexports.x = 'a2';\n\n// b.js\nexports.x = 'b1';\nconsole.log('b.js ', require('./a.js').x);\nexports.x = 'b2';\n\n// main.js\nconsole.log('main.js ', require('./a.js').x);\nconsole.log('main.js ', require('./b.js').x);\n")])])]),s("p",[e._v("上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ node main.js\nb.js  a1\na.js  b2\nmain.js  a2\nmain.js  b2\n")])])]),s("p",[e._v("修改main.js，再次加载a.js和b.js。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// main.js\nconsole.log('main.js ', require('./a.js').x);\nconsole.log('main.js ', require('./b.js').x);\nconsole.log('main.js ', require('./a.js').x);\nconsole.log('main.js ', require('./b.js').x);\n")])])]),s("p",[e._v("执行上面代码，结果如下。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ node main.js\nb.js  a1\na.js  b2\nmain.js  a2\nmain.js  b2\nmain.js  a2\nmain.js  b2\n")])])]),s("p",[e._v("上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。")]),e._v(" "),s("h3",{attrs:{id:"require-main"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require-main"}},[e._v("#")]),e._v(" require.main")]),e._v(" "),s("p",[s("code",[e._v("require")]),e._v("方法有一个"),s("code",[e._v("main")]),e._v("属性，可以用来判断模块是直接执行，还是被调用执行。")]),e._v(" "),s("p",[e._v("直接执行的时候（"),s("code",[e._v("node module.js")]),e._v("），"),s("code",[e._v("require.main")]),e._v("属性指向模块本身。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("require.main === module\n// true\n")])])]),s("p",[e._v("调用执行的时候（通过"),s("code",[e._v("require")]),e._v("加载该脚本执行），上面的表达式返回false。")]),e._v(" "),s("h2",{attrs:{id:"模块的加载机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块的加载机制"}},[e._v("#")]),e._v(" 模块的加载机制")]),e._v(" "),s("p",[e._v("CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。")]),e._v(" "),s("p",[e._v("下面是一个模块文件"),s("code",[e._v("lib.js")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n")])])]),s("p",[e._v("上面代码输出内部变量"),s("code",[e._v("counter")]),e._v("和改写这个变量的内部方法"),s("code",[e._v("incCounter")]),e._v("。")]),e._v(" "),s("p",[e._v("然后，加载上面的模块。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n")])])]),s("p",[e._v("上面代码说明，"),s("code",[e._v("counter")]),e._v("输出以后，"),s("code",[e._v("lib.js")]),e._v("模块内部的变化就影响不到"),s("code",[e._v("counter")]),e._v("了。")]),e._v(" "),s("h3",{attrs:{id:"require的内部处理流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require的内部处理流程"}},[e._v("#")]),e._v(" require的内部处理流程")]),e._v(" "),s("p",[s("code",[e._v("require")]),e._v("命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的"),s("code",[e._v("module.require")]),e._v("命令，而后者又调用Node的内部命令"),s("code",[e._v("Module._load")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Module._load = function(request, parent, isMain) {\n  // 1. 检查 Module._cache，是否缓存之中有指定模块\n  // 2. 如果缓存之中没有，就创建一个新的Module实例\n  // 3. 将它保存到缓存\n  // 4. 使用 module.load() 加载指定的模块文件，\n  //    读取文件内容之后，使用 module.compile() 执行文件代码\n  // 5. 如果加载/解析过程报错，就从缓存删除该模块\n  // 6. 返回该模块的 module.exports\n};\n")])])]),s("p",[e._v("上面的第4步，采用"),s("code",[e._v("module.compile()")]),e._v("执行指定模块的脚本，逻辑如下。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Module.prototype._compile = function(content, filename) {\n  // 1. 生成一个require函数，指向module.require\n  // 2. 加载其他辅助方法到require\n  // 3. 将文件内容放到一个函数之中，该函数可调用 require\n  // 4. 执行该函数\n};\n")])])]),s("p",[e._v("上面的第1步和第2步，"),s("code",[e._v("require")]),e._v("函数及其辅助方法主要如下。")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("require()")]),e._v(": 加载外部模块")]),e._v(" "),s("li",[s("code",[e._v("require.resolve()")]),e._v("：将模块名解析到一个绝对路径")]),e._v(" "),s("li",[s("code",[e._v("require.main")]),e._v("：指向主模块")]),e._v(" "),s("li",[s("code",[e._v("require.cache")]),e._v("：指向所有缓存的模块")]),e._v(" "),s("li",[s("code",[e._v("require.extensions")]),e._v("：根据文件的后缀名，调用不同的执行函数")])]),e._v(" "),s("p",[e._v("一旦"),s("code",[e._v("require")]),e._v("函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括"),s("code",[e._v("require")]),e._v("、"),s("code",[e._v("module")]),e._v("、"),s("code",[e._v("exports")]),e._v("，以及其他一些参数。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function (exports, require, module, __filename, __dirname) {\n  // YOUR CODE INJECTED HERE!\n});\n")])])]),s("p",[s("code",[e._v("Module._compile")]),e._v("方法是同步执行的，所以"),s("code",[e._v("Module._load")]),e._v("要等它执行完成，才会向用户返回"),s("code",[e._v("module.exports")]),e._v("的值。")])])}),[],!1,null,null,null);a.default=r.exports}}]);