(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{631:function(t,a,s){"use strict";s.r(a);var r=s(17),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[t._v("#")]),t._v(" 树")]),t._v(" "),s("p",[t._v("树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。")]),t._v(" "),s("p",[t._v("树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。")]),t._v(" "),s("h2",{attrs:{id:"二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),s("p",[s("code",[t._v("二叉树")]),t._v("是一种更为典型的树状结构。\n每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。")]),t._v(" "),s("h2",{attrs:{id:"树的遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树的遍历"}},[t._v("#")]),t._v(" 树的遍历")]),t._v(" "),s("h3",{attrs:{id:"前序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前序"}},[t._v("#")]),t._v(" 前序")]),t._v(" "),s("p",[t._v("前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。")]),t._v(" "),s("h3",{attrs:{id:"中序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中序"}},[t._v("#")]),t._v(" 中序")]),t._v(" "),s("p",[t._v("中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。")]),t._v(" "),s("h3",{attrs:{id:"后序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后序"}},[t._v("#")]),t._v(" 后序")]),t._v(" "),s("p",[t._v("后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。")]),t._v(" "),s("h3",{attrs:{id:"层序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#层序"}},[t._v("#")]),t._v(" 层序")]),t._v(" "),s("p",[t._v("层序遍历就是逐层遍历树结构。")]),t._v(" "),s("p",[t._v("广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。\n当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。")])])}),[],!1,null,null,null);a.default=v.exports}}]);